from youtube_transcript_api import YouTubeTranscriptApi
from youtube_transcript_api.formatters import TextFormatter
import asyncio
import re

def _transcript(video_id, code_language='en', cookies=None):
    """
    Fetch transcript for a single video ID.
    Args:
        video_id (str): A single video ID to fetch transcript for.
        code_language (str): Language code for the transcript. Default='en'
        cookies (str): Path to cookies file.
    Returns:
        dict: A dictionary mapping video ID to its transcript.
    """
    try:
        transcript_list = YouTubeTranscriptApi.list_transcripts(video_id, cookies=cookies)
        # Identify the languages and types of the transcripts
        l_language = [
            (i.language_code, i.is_generated) for i in transcript_list 
                if i.language_code==code_language 
                    or code_language in [j['language_code'] for j in i.translation_languages]
            ]
        # If code_language -> get autogenerated or manual. 
        # If NOT code_language -> get autogenerated or manual with code_language translation
        # If NO code_language translation -> return empty
        if (code_language, True) in l_language:
            transcript = transcript_list.find_generated_transcript([code_language])
            return {
                'videoId': transcript.video_id, 
                'language': transcript.language_code,
                'is_generated': transcript.is_generated,
                'transcript': transcript.fetch()
            }
        elif (code_language, False) in l_language:
            transcript = transcript_list.find_manually_created_transcript([code_language])
            return {
                'videoId': transcript.video_id, 
                'language': transcript.language_code,
                'is_generated': transcript.is_generated,
                'transcript': transcript.fetch()
            }
        else:
            generated = next((item for item in l_language if item[1] is True), None)
            manual = next((item for item in l_language if item[1] is False), None)
            if generated:
                transcript = transcript_list.find_generated_transcript([generated[0]])
                translated_transcript = transcript.translate(code_language)
                return {
                        'videoId': transcript.video_id, 
                        'language': transcript.language_code,
                        'is_generated': transcript.is_generated,
                        'transcript': translated_transcript.fetch()
                    }
            elif manual:
                transcript = transcript_list.find_manually_created_transcript([manual[0]])
                translated_transcript = transcript.translate(code_language)
                return {
                        'videoId': transcript.video_id, 
                        'language': transcript.language_code,
                        'is_generated': transcript.is_generated,
                        'transcript': translated_transcript.fetch()
                    }
            else:
                return None
    except:
        return None


# Asynchronous function to call the blocking function
async def transcript(video_id, code_language='en', cookies=None):
    """
    Fetch transcript for multiple video IDs concurrently.
    Args:
        video_id (str/list): A single video ID or list of video IDs to fetch transcript for.
        code_language (str): Language code for the transcript. Default='en'
        cookies (str): Path to cookies file.
    Returns:
        dict: A dictionary mapping video IDs to their respective transcripts.
    """
    if isinstance(video_id, str):
        result = _transcript(video_id, code_language, cookies)
        result['transcript'] = formatter.format_transcript(result['transcript'])
        return result
    
    else:
        tasks = []
        for value in video_id:
            # Schedule the blocking function to run in a separate thread
            tasks.append(asyncio.to_thread(_transcript, value, code_language='en', cookies=None))
        
        # Wait for all tasks to complete
        results = await asyncio.gather(*tasks)

        # Clean up transcripts
        formatter = TextFormatter()
        for i in results:
            if i:
                i['transcript'] = re.sub(r'[\r\n\s]+', ' ', formatter.format_transcript(i['transcript']))

        return results